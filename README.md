# Scott: Un Ejemplo de DSL Funcional en Java

![tl-dr;](docs/img/tl-dr.png)
Este repositorio ilustra el dise침o, implementaci칩n y uso de un lenguaje de dominio espec칤fico (DSL) en Java 17
empleando patrones funcionales.
El argumento de estudio es una aplicaci칩n SpringBoot JPA inspirada en el tradicional esquema Oracle _scott/tiger_.
Para comprender las t칠cnicas empleadas para implementar este DSL se requiere familiaridad con las 
[lambdas de Java](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html) 
as칤 como con 
[Spring Data JPA](https://spring.io/projects/spring-data-jpa).

El DSL implementado en este repositorio captura patrones repetitivos en el uso de repositorios JPA desde componentes 
Spring con estereotipo de servicio (`@Service`).

Un servicio Spring t칤pico implementar칤a imperativamente la persistencia de una nueva instancia de `Departamento` en 
la base de datos como:

```java
// Retorna el id generado para una nueva instancia de departamento persistida exitosamente
// o causa una excepci칩n en cada posible escenario de falla
public String crearDepartamento(String codigo, String nombre, String localidad) {
    // Construye y valida instancia de departamento
    final Departamento departamento;
    try {
        departamento = Departamento.builder()
                .codigo(codigo)
                .nombre(nombre)
                .localidad(localidad)
                .build();
    } catch (Exception e) {
        throw new RuntimeException("Error de validaci칩n creando departamento", e);
    }

    // Persiste nuevo departamento
    final Departamento departamentoGuardado;
    try {
        departamentoGuardado = repositorioDepartamento.save(departamento);
    } catch (Exception e) {
        throw new RuntimeException("Error persistiendo nuevo departamento", e);
    }

    // Retorna id generado para nuevo departamento
    return departamentoGuardado.getId();
}
```

Empleando el DSL implementado en este repositorio, la misma funcionalidad lucir칤a como:

```java
// Retorna id generado para nueva instancia de departamento
public String crearDepartamento(String codigo, 
                                String nombre, 
                                String localidad) {
  return persistirInstancia(
    repositorioDepartamento,
    () -> Departamento.builder()
      .codigo(codigo)
      .nombre(nombre)
      .localidad(localidad)
      .build()
    ));
}
```

## El Modelo de Datos _scott/tiger_

El modelo de datos de ejemplo esta inspirado en el esquema 
[scott/tiger](https://www.orafaq.com/wiki/SCOTT) tradicionalmente empleado por Oracle 
Corporation para ense침ar el lenguaje SQL. 

Adem치s de reformularlo en espa침ol, en este repositorio se le a침ade a este modelo algunos peque침os detalles para 
utilizarlo mediante JPA:

![Modelo](docs/img/modelo.png)

La definici칩n de `Departamento` como entidad JPA mostrada a continuaci칩n hace uso de 
[Lombok](https://www.javatpoint.com/lombok-java) y de 
[Java EE Validation](https://docs.oracle.com/javaee/7/tutorial/bean-validation.htm)
as칤 como del soporte brindado por la superclase 
[Entidad](src/main/java/scott/infra/jpa/entidad/Entidad.java):

```java
@Entity
@Table(name = "departamento", 
  uniqueConstraints = { @UniqueConstraint(name = "dept_uk_codigo",  
    columnNames = {"codigo"})})
@Getter
@ToString(onlyExplicitlyIncluded = true)
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class Departamento extends Entidad {
  @ToString.Include
  @NotNull(message = "El c칩digo del departamento debe ser especificado")
  @Pattern(regexp = "^[0-9]{2}$", message = "C칩digo de departamento inv치lido; debe constar de dos d칤gitos")
  @Basic(optional = false)
  @Column(name = "codigo", nullable = false, length = 2)
  private String codigo;

  @ToString.Include
  @NotNull(message = "El nombre del departamento debe ser especificado")
  @Pattern(regexp = "^\\p{IsLatin}{2,16}$", message = "Nombre de departamento inv치lido; solo puede contener letras")
  @Basic(optional = false)
  @Column(name = "nombre", nullable = false, length = 16)
  private String nombre;

  @ToString.Include
  @NotNull(message = "La localidad del departamento debe ser especificada")
  @Pattern(regexp = "^\\p{IsLatin}{2,16}$", message = "Localidad de departamento inv치lida; solo puede contener letras")
  @Basic(optional = false)
  @Column(name = "localidad", nullable = false, length = 16)
  private String localidad;

  @OneToMany(mappedBy = "departamento", cascade = CascadeType.ALL)
  private final Set<Empleado> empleados = new HashSet<>();

  @Builder
  public Departamento(String codigo, 
                      String nombre, 
                      String localidad) {
    this.codigo = codigo;
    this.nombre = nombre;
    this.localidad = localidad;
    validarAtributos();
  }

  public String relocalizar(String nuevaLocalidad) {
    String localidadOriginal = this.localidad;
    this.localidad = nuevaLocalidad;
    validarAtributos();
    return localidadOriginal;
  }
}
```

## Insertando una Nueva Instancia de Entidad (Toma 1)

Para persistir una nueva instancia de `Departamento` se requerir칤a algo como:

```java
public String crearDepartamento(String codigo, 
                                String nombre,
                                String localidad) {
  // Construye y valida instancia de departamento
  final Departamento departamento;
  try {
    departamento = Departamento.builder()
      .codigo(codigo)
      .nombre(nombre)
      .localidad(localidad)
      .build();
  } catch (Exception e) {
    throw new RuntimeException("Error de validaci칩n creando departamento", e);
  }

  // Persiste nuevo departamento
  final Departamento departamentoGuardado;
  try {
    departamentoGuardado = 
        repositorioDepartamento.save(departamento);
  } catch (Exception e) {
    throw new RuntimeException("Error de persistencia creando departamento", e);
  }

  // Retorna id generado para nuevo departamento
  return departamentoGuardado.getId();
}
```

Para persistir una nueva instancia de `Empleado` se requerir칤a algo _muy semejante_, en el estilo de:

```java
public String crearEmpleado(String codigo, String nombre, Genero genero) {
  // Construye y valida instancia de empleado
  final Empleado empleado;
  try {
    empleado = Empleado.builder()
      .codigo(codigo)
      .nombre(nombre)
      .genero(genero)
      .build();
  } catch (Exception e) {
    throw new RuntimeException("Error de validaci칩n creando empleado", e);
  }

  // Persiste nuevo Empleado
  final Empleado empleadoGuardado;
  try {
    empleadoGuardado = 
      repositorioEmpleado.save(empleado);
  } catch (Exception e) {
    throw new RuntimeException("Error de persistencia creando empleado", e);
  }

  // Retorna id generado para nuevo empleado
  return empleadoGuardado.getId();
}
```

En los dos casos se repite el mismo patr칩n:

- Declarar y poblar una nueva instancia de la entidad, generando una excepci칩n si hay errores de validaci칩n
- Guardar la nueva instancia creando as칤 una nueva versi칩n ya almacenada y generando una excepci칩n si hay errores 
  de persistencia
- Retornar la nueva clave primaria generada por el sistema

Var칤an los detalles, pero el c칩digo (repetitivo y tedioso) tiene siempre la misma estructura.

## Claves Naturales y Sint칠ticas

En el uso de bases de datos relacionales de hoy es frecuente reemplazar las claves primarias "naturales" (tales como 
la _c칠dula_ de la persona o el _c칩digo_ del departamento) por claves primarias "sint칠ticas" generadas por el sistema.

```sql
CREATE TABLE departamento (
  id   INTEGER   NOT NULL DEFAULT nextval('departamento_seq') PRIMARY KEY,
  codigo VARCHAR(16) NOT NULL UNIQUE,
  nombre VARCHAR(24) NOT NULL
);
CREATE TABLE empleado (
  id        VARCHAR(32) NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  codigo      VARCHAR(16) NOT NULL UNIQUE,
  nombre      VARCHAR(24) NOT NULL,
  id_departamento INTEGER   NOT NULL REFERENCES departamento (id),
  id_supervisor   VARCHAR(32) REFERENCES empleado (id)
);
```

Para impedir que se a침adan nuevas instancias con valores duplicados de clave natural es necesario verificar, al 
crear una nueva instancia de la entidad, que no exista ya en su tabla una fila con el mismo valor. As칤 mismo, se 
requiere a침adir a las entidades JPA una anotaci칩n `@Table/@UniqueConstraint`

游녤 En nuestro repositorio de ejemplo hemos establecido la simplificaci칩n de que todas las claves primarias sint칠ticas
son de tipo `String` y corresponden a un _random `UUID`_ generado desde la aplicaci칩n.

## Insertando una Nueva Instancia de Entidad (Toma 2)

Para garantizar que no haya m칰ltiples departamentos con el mismo c칩digo, la persistencia de una nueva instancia de 
`Departamento` lucir칤a ahora como:

```java
public String crearDepartamento(String codigo, String nombre, String localidad) {
  // Valida que el c칩digo de departamento no sea duplicado
  final Optional<Departamento> optDepartamento;
  try {
    optDepartamento = 
      repositorioDepartamento.findByCodigo(codigo);
  } catch (Exception e) {
    throw new RuntimeException("Error recuperando departamento por c칩digo", e);
  }
  optDepartamento.ifPresent(d -> {
    String mensaje = "Ya existe un departamento con codigo %s: %s!".formatted(codigo, d.getNombre());
    throw new IllegalArgumentException(mensaje);
  });
  
  // Construye y valida instancia de departamento
  final Departamento departamento;
  try {
    departamento = Departamento.builder()
      .codigo(codigo)
      .nombre(nombre)
      .localidad(localidad)
      .build();
  } catch (Exception e) {
    throw new RuntimeException("Error de validaci칩n creando departamento", e);
  }

  // Persiste nuevo departamento
  final Departamento departamentoGuardado;
  try {
    departamentoGuardado = repositorioDepartamento.save(departamento);
  } catch (Exception e) {
    throw new RuntimeException("Error de persistencia creando departamento", e);
  }

  // Retorna id generado para nuevo departamento
  return departamentoGuardado.getId();
}
```

La creaci칩n de una nueva entidad de `Empleado` se ver치 tambi칠n aumentada con una verificaci칩n adicional equivalente.

Esto es repetitivo, tedioso y _propenso al error_!

游녤 **Una de las principales fuentes de _bugs_ en el desarrollo de aplicaciones son los errores en la transcripci칩n de 
recetas repetitivas como esta**.

## Capturando Recetas Repetitivas  (Toma 1)

Qu칠 partes var칤an de caso en caso en la receta repetitiva que nos ocupa? 

Qu칠 es lo que cambia de entidad en entidad cuando queremos persistir una nueva instancia en la base de datos?

- Cambia el tipo de datos concreto de la entidad (`Departamento`, `Empleado`, ...)
- Cambia la porci칩n de l칩gica que construye y valida una nueva instancia de la entidad en memoria
- Cambia el m칠todo del repositorio que localiza una instancia dado el valor de la clave primaria natural

Todo lo dem치s tiene _siempre_ la misma l칩gica!

Para formular las partes m칩viles de forma reutilizable Java provee dos poderosos aliados: 

- Tipos de datos gen칠ricos y 
- Lambdas

Dado que todas las clases que nos ata침en extienden la superclase `Entidad` podemos definir para nuestro m칠todo un 
tipo de datos gen칠rico `<E extends Entidad>`. Por extensi칩n, el tipo del repositorio ser칤a 
`<R extends JpaRepository<E, String>>`.

La porci칩n de l칩gica que construye en memoria una nueva instancia de entidad es una lambda de tipo `Supplier<E>`.

La porci칩n de l칩gica que retorna una posible instancia de entidad ya existente para el nuevo valor de clave primaria 
natural ser칤a un ``Supplier<Optional<E>>``.

Veamos:

```java
public static<E, I> I persistirInstancia(
  JpaRepository<E, I> repositorio,
  Function<E, I> clavePrimaria,
  Consumer<E> validacion,
  Supplier<E> crearInstancia
) {
  final E entidad;
  try{
    entidad = crearInstancia.get();
  } catch(Exception e){
    throw new ExcepcionServicio("Error creando instancia de entidad en memoria",e);
  }

  if(validacion != null) {
    try{
      validacion.accept(entidad);
    } catch(ExcepcionServicio e){
        throw e;
    } catch(Exception e){
      throw new ExcepcionServicio("Error de validaci칩n de entidad",e);
    }
  }

  final E entidadGuardada;
  try {
    entidadGuardada = repositorio.save(entidad);
  } catch(Exception e) {
    throw new ExcepcionServicio("Error persistiendo nueva instancia",e);
  }

  return clavePrimaria.apply(entidadGuardada);
}
```

Armados con este m칠todo gen칠rico, la creaci칩n de un nuevo departamento lucir칤a como:

```java
public String crearDepartamento(
  String codigo, 
  String nombre, 
  String localidad) 
{
  return persistirInstancia(
    repositorioDepartamento,
    detectarDuplicado(repositorioDepartamento::buscarPorCodigo, codigo),
    () -> Departamento.builder()
      .codigo(codigo)
      .nombre(nombre)
      .localidad(localidad)
      .build()
  ));
}
```

游뱔 Aah, _excelente_ simplificaci칩n! 

Y es segura en tipos de datos! Si, por error, escribi칠ramos `repositorioEmpleado` donde debiera decir 
`repositorioDepartamento`, el compilador de Java y/o la IDE nos lo har칤an saber _de inmediato_.

## Capturando Recetas Repetitivas  (Toma 2)

Nuestro m칠todo DSL `persistirInstancia` nos ha tra칤do grandes beneficios ya desde su primera encarnaci칩n. 

Pero, como todo en la vida, esta soluci칩n es imperfecta:

- No soluciona _todos_ nuestros problemas
- Nos trae _nuevos_ problemas causados por ella misma

Qu칠 problemas nuevos nos trae? 

Uno inmediatamente evidente es que los mensajes de error son demasiado gen칠ricos y no proveen contexto. Donde 
nuestra versi칩n original sol칤a decir `Ya existe un departamento con codigo 30: Ventas!` ahora nuestro m칠todo DSL 
reporta un cr칤ptico `Ya existe una entidad con la misma clave natural`. Claramente, esto necesita mejorar.

Qu칠 problemas no soluciona?

Un problema con nuestro c칩digo original es que hace uso muy liberal de las excepciones.

Algunos programadores Java no ver칤an en esto un problema. Despues de todo, las excepciones son el mecanismo est치ndar 
del lenguaje para reportar o reaccionar a condiciones de error.

Sin embargo, las excepciones rompen el control de flujo y, tomadas a la ligera, dificultan lidiar con condiciones de 
error. 

游녤 En la vida pr치ctica, muchos desarrolladores simplemente ignoran las excepciones y las dejan propagar 
hasta el nivel superior de la aplicaci칩n! _Somewhere in the Rytridian Galaxy, Ultra Lord weeps 游봌_



